import { describe, expect, it, beforeEach, afterEach, vi } from "vitest";
import { SecurityError } from "../../errors/security-error.js";

// Mock fs/promises to avoid writing to disk during tests
vi.mock("node:fs/promises", () => ({
  readFile: vi.fn().mockResolvedValue("{}"),
  writeFile: vi.fn().mockResolvedValue(undefined),
  access: vi.fn().mockRejectedValue(new Error("File not found")),
  mkdir: vi.fn().mockResolvedValue(undefined),
}));

vi.mock("node:path", () => ({
  join: vi.fn((...parts) => parts.join("/")),
}));

// Need to import the module fresh for each test to test the resolveEncryptionSecret function
// Since it's not exported, we'll test it through the handlers behavior

const ORIGINAL_ENV = process.env;

describe("env encryption secret validation", () => {
  beforeEach(() => {
    // Reset env before each test
    process.env = { ...ORIGINAL_ENV };
    delete process.env.OPENCLAW_ENV_ENCRYPTION_KEY;
    delete process.env.SESSION_SECRET;
  });

  afterEach(() => {
    // Restore original env
    process.env = ORIGINAL_ENV;
  });

  it("should throw SecurityError when no encryption key is set", async () => {
    // Remove any existing encryption keys
    delete process.env.OPENCLAW_ENV_ENCRYPTION_KEY;
    delete process.env.SESSION_SECRET;

    // Import the module fresh to trigger the validation
    const { envHandlers } = await import("./env.js");

    // Attempt to set an encrypted env var should fail
    const respond = vi.fn();
    await envHandlers["env.set"]({
      params: {
        sessionKey: "test-session",
        key: "MY_SECRET",
        value: "sensitive-value",
        encrypt: true,
      },
      respond,
      context: {} as any,
      req: { type: "req", id: "1", method: "env.set" },
      client: null,
      isWebchatConnect: () => false,
    });

    // Should have responded with failure (success = false)
    expect(respond).toHaveBeenCalled();
    const [success] = respond.mock.calls[0];
    expect(success).toBe(false);
  });

  it("should throw SecurityError when encryption key is too short", async () => {
    // Set a weak/short key
    process.env.OPENCLAW_ENV_ENCRYPTION_KEY = "short";

    const { envHandlers } = await import("./env.js");

    const respond = vi.fn();
    await envHandlers["env.set"]({
      params: {
        sessionKey: "test-session",
        key: "MY_SECRET",
        value: "sensitive-value",
        encrypt: true,
      },
      respond,
      context: {} as any,
      req: { type: "req", id: "2", method: "env.set" },
      client: null,
      isWebchatConnect: () => false,
    });

    expect(respond).toHaveBeenCalled();
    const [success] = respond.mock.calls[0];
    expect(success).toBe(false);
  });

  it("should accept valid 32+ character encryption key", async () => {
    // Set a valid key (32+ characters)
    process.env.OPENCLAW_ENV_ENCRYPTION_KEY = "a".repeat(32);

    const { envHandlers } = await import("./env.js");

    const respond = vi.fn();
    await envHandlers["env.set"]({
      params: {
        sessionKey: "test-session",
        key: "MY_SECRET",
        value: "sensitive-value",
        encrypt: true,
      },
      respond,
      context: {} as any,
      req: { type: "req", id: "3", method: "env.set" },
      client: null,
      isWebchatConnect: () => false,
    });

    expect(respond).toHaveBeenCalled();
    const [success] = respond.mock.calls[0];
    expect(success).toBe(true);
  });

  it("should accept SESSION_SECRET as fallback", async () => {
    // Set SESSION_SECRET instead of OPENCLAW_ENV_ENCRYPTION_KEY
    process.env.SESSION_SECRET = "b".repeat(32);

    const { envHandlers } = await import("./env.js");

    const respond = vi.fn();
    await envHandlers["env.set"]({
      params: {
        sessionKey: "test-session",
        key: "MY_SECRET",
        value: "sensitive-value",
        encrypt: true,
      },
      respond,
      context: {} as any,
      req: { type: "req", id: "4", method: "env.set" },
      client: null,
      isWebchatConnect: () => false,
    });

    expect(respond).toHaveBeenCalled();
    const [success] = respond.mock.calls[0];
    expect(success).toBe(true);
  });

  it("should accept hex key generated by crypto.randomBytes(32)", async () => {
    // Set a valid hex key (64 characters = 32 bytes hex encoded)
    process.env.OPENCLAW_ENV_ENCRYPTION_KEY = "a1b2c3d4e5f6".repeat(6);

    const { envHandlers } = await import("./env.js");

    const respond = vi.fn();
    await envHandlers["env.set"]({
      params: {
        sessionKey: "test-session",
        key: "MY_SECRET",
        value: "sensitive-value",
        encrypt: true,
      },
      respond,
      context: {} as any,
      req: { type: "req", id: "5", method: "env.set" },
      client: null,
      isWebchatConnect: () => false,
    });

    expect(respond).toHaveBeenCalled();
    const [success] = respond.mock.calls[0];
    expect(success).toBe(true);
  });
});

describe("SecurityError class", () => {
  it("should have correct structure", () => {
    const error = new SecurityError("Test message", "TEST_CODE", {
      docsUrl: "https://example.com/docs",
    });

    expect(error.name).toBe("SecurityError");
    expect(error.message).toBe("Test message");
    expect(error.code).toBe("TEST_CODE");
    expect(error.metadata?.docsUrl).toBe("https://example.com/docs");
    expect(error).toBeInstanceOf(Error);
  });

  it("should work without metadata", () => {
    const error = new SecurityError("Test message", "TEST_CODE");

    expect(error.name).toBe("SecurityError");
    expect(error.message).toBe("Test message");
    expect(error.code).toBe("TEST_CODE");
    expect(error.metadata).toBeUndefined();
  });
});
